ifrom django.core.cache import cache
from providers.utils.payufin.finnone_v8_apis import PayUFinV8API

def test_forbidden_error_handling():
    print("\n" + "="*50)
    print("TEST: 403 FORBIDDEN CACHE CLEAR")
    print("="*50)

    # 1. Setup: Put a "stale" token in the cache
    test_token = "stale_token_123"
    token_key = PayUFinV8API.PAYUFIN_ACCESS_TOKEN
    cache.set(token_key, test_token, 900)
    print(f"[1] Initial: Token '{test_token}' placed in cache.")

    # 2. Simulate the 403 Error
    print("[2] Simulating a 403 Forbidden response...")
    
    # This simulates the logic inside your API exception handler
    status_code = 403 
    
    if status_code in [401, 403]:
        print(f"    Detected {status_code}. Triggering cache delete...")
        cache.delete(token_key)
    
    # 3. Verification
    cached_after = cache.get(token_key)
    
    print("-" * 50)
    if cached_after is None:
        print("RESULT: ✓ PASS")
        print("Logic correctly cleared the cache. The next API call will fetch a fresh token.")
    else:
        print("RESULT: ✗ FAIL")
        print(f"Logic failed. The stale token '{cached_after}' is still in cache.")
    print("="*50 + "\n")

# Execute the test
test_forbidden_error_handling()




```python

def refresh_access_token(self):

    LOGGER.warning("Refreshing V8 token")

    cache.delete(self.PAYUFIN_ACCESS_TOKEN)

    data = self._get_access_token()

    new_token = data["access_token"]

    cache.set(
        self.PAYUFIN_ACCESS_TOKEN,
        new_token,
        self.ACCESS_TOKEN_EXPIRE
    )

    self.access_token = new_token   # optional but nice

    LOGGER.warning("New token stored")

    return new_token


if status_code in [401, 403]:

    LOGGER.warning(f"Invalid token {status_code}")

    if getattr(self, "_token_retry", False):
        raise e

    self._token_retry = True
    try:
        self.refresh_access_token()
        return func(self, *args, **kwargs)
    finally:
        self._token_retry = False

## Summary
Implements automatic token refresh when Finnone V8 API returns 401/403 token expiry errors.

## Problem
When the access token expires before the 15-minute cache TTL, API calls fail with 401/403 errors. The system was not handling these errors, causing subsequent requests to continue using the expired token.

## Solution
- Added token expiry detection in `conditional_decorator` (apis.py)
- Clear expired token from cache on 401/403 error
- Automatic retry using existing `access_token` property which fetches fresh token
- Added retry loop prevention using `_token_retry` flag

## Changes Made
**Files Modified:**
- `providers/utils/payufin/apis.py`: Enhanced `conditional_decorator` with token expiry handling
- `providers/utils/payufin/finnone_v8_apis.py`: Ensured `access_token` property works with cache clearing

## How It Works
1. API call with expired token → 401/403 error
2. Decorator catches `TokenExpire` exception
3. Clears cached token: `cache.delete(self.__class__.PAYUFIN_ACCESS_TOKEN)`
4. Retries request
5. `access_token` property sees empty cache → fetches new token
6. Request succeeds with fresh token

## Testing Done
✅ Manually set invalid token in cache
✅ Made API request → Got 403 error
✅ Verified cache was cleared
✅ Confirmed new token was fetched
✅ Verified retry mechanism works
✅ Tested retry loop prevention

## Ticket
Fixes: COL-10227

